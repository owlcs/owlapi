options {
    STATIC=false;
    //LOOKAHEAD=2;
    //DEBUG_TOKEN_MANAGER=true;
    //DEBUG_PARSER=true;
}

PARSER_BEGIN(TurtleParser)

package uk.ac.manchester.cs.owl.turtle.parser;

import org.semanticweb.owl.vocab.OWLRDFVocabulary;
import org.semanticweb.owl.vocab.XSDVocabulary;
import org.semanticweb.owl.model.*;
import java.net.*;
import java.util.*;
import java.io.Reader;
import java.io.InputStream;
import org.coode.owl.rdfxml.parser.AnonymousNodeChecker;
import org.coode.string.EscapeUtils;

public class TurtleParser implements AnonymousNodeChecker {

    private OWLOntology ontology;

    private OWLDataFactory dataFactory;

    private Map<String, URI> string2URI;

    private Map<String, String> prefix2NamespaceMap;

    private boolean ignoreAnnotationsAndDeclarations = false;

    private String base;

    private int blankNodeId;

    private TripleHandler handler;


    public TurtleParser(Reader reader, TripleHandler handler, String base) {
        this(reader);
        this.handler = handler;
        this.base = base;
        string2URI = new HashMap<String, URI>();
        blankNodeId = 0;
        prefix2NamespaceMap = new HashMap<String, String>();
        prefix2NamespaceMap.put("", "");
        prefix2NamespaceMap.put(null, "");
        prefix2NamespaceMap.put("_", "");
    }

    public TurtleParser(InputStream is, TripleHandler handler, String base) {
        this(is);
        this.handler = handler;
        this.base = base;
        string2URI = new HashMap<String, URI>();
        blankNodeId = 0;
        prefix2NamespaceMap = new HashMap<String, String>();
        prefix2NamespaceMap.put("", "");
        prefix2NamespaceMap.put("_", "");
    }

    public void setTripleHandler(TripleHandler handler) {
        this.handler = handler;
    }

    public boolean isAnonymousNode(String uri) {
        return uri.indexOf("genid") != -1;
    }


    public boolean isAnonymousNode(URI uri) {
        String frag = uri.getFragment();
        return frag != null && frag.indexOf("genid") != -1;
    }

    protected URI getNextBlankNode() {
        URI uri = getURI("genid" + blankNodeId);
        blankNodeId++;
        return uri;
    }

    protected URI getURIFromQName(String qname) {
        int sepIndex = qname.indexOf(':');
        String prefix = "";
        String localName = qname;
        if(sepIndex != -1) {
            prefix = qname.substring(0, sepIndex);
            localName = qname.substring(sepIndex + 1, qname.length());
        }
        String ns = prefix2NamespaceMap.get(prefix);
        return getURI(ns + localName);
    }

    protected void addAxiom(OWLAxiom ax) throws TurtleParserException {
        try {
            ((OWLMutableOntology) ontology).applyChange(new AddAxiom(ontology, ax));
        }
        catch(OWLOntologyChangeException e) {
            throw new TurtleParserException(e);
        }
    }

    public URI getURI(String s) {
         if(s.charAt(0) == '<') {
            s = s.substring(1, s.length() - 1);
        }

        URI uri = string2URI.get(s);
        if(uri == null) {
            try {
                uri = new URI(s);

                if(!uri.isAbsolute()) {
                    String uriString = uri.toString();
                    if(uri.getFragment() != null) {
                        uri = new URI(base + uriString);
                    }
                    else {
                        if(base.endsWith("/")) {
                            uri = new URI(base + uriString);
                        }
                        else {
                            uri = new URI(base + "#" + uriString);
                        }
                    }

                }
                string2URI.put(s, uri);
            }
            catch(URISyntaxException e) {
                throw new RuntimeException(e);
            }
        }
        return uri;
    }

    public void setIgnoreAnnotationsAndDeclarations(boolean b) {
        ignoreAnnotationsAndDeclarations = b;
    }

}

PARSER_END(TurtleParser)

SKIP: {" " | "\n" | "\t" | "\r"}

SKIP:
{
    <COMMENT: "#" (~["\n"])*>
}

/////////////////////////////////////////////////////////////////////////////////////////////

MORE : {
    "\"": IN_STRING
}

<IN_STRING> MORE :
{
    <  ~["\"" , "\\"] >
}


<IN_LONG_STRING> MORE :
{
    < "\\"~[] >
}

<IN_STRING> TOKEN:
{
    <STRING: "\""> : DEFAULT
}

MORE : {
    "\"\"\"" : IN_LONG_STRING
}

<IN_LONG_STRING> MORE :
{
    <  ~["\\"] >
}

<IN_LONG_STRING> MORE :
{
    < "\\"~[] >
}

<IN_LONG_STRING> TOKEN :
{
    <LONG_STRING: "\"\"\""> : DEFAULT
}


/////////////////////////////////////////////////////////////////////////////////////////////

TOKEN:
{
    <DIGIT: ["0"-"9"]>
}

TOKEN:
{
    <INTEGER: ("+" | "-")? (<DIGIT>)+>
}

TOKEN:
{
    <DOUBLE: ("-" | "+") ? (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT> | "." (<DIGIT>)+ <EXPONENT> | (<DIGIT>)+ <EXPONENT>)>
}

TOKEN:
{
    <DECIMAL: ("-" | "+")? ( (<DIGIT>)+ "." (<DIGIT>)* | "." (<DIGIT>)+ | (<DIGIT>)+ )>
}


TOKEN:
{
    <EXPONENT: 	("e" | "E") ("-" | "+")? (<DIGIT>)+>
}


TOKEN:
{
    <OPENPAR: "(">
}

TOKEN:
{
    <CLOSEPAR: ")">
}


TOKEN:
{
    <COMMA: ",">
}

TOKEN:
{
    <DOT: ".">
}

TOKEN:
{
    <SEMICOLON: ";">
}

TOKEN:
{
    <PREFIX: "@prefix">
}

TOKEN:
{
    <DOUBLE_CARET: "^^">
}

TOKEN:
{
    <BASE: "@base">
}

TOKEN:
{
    <AT: "@">
}


TOKEN:
{
    <A: "a">
}


TOKEN:
{
    <EMPTY_BLANK_NODE: "[]">
}



TOKEN:
{
    <OPEN_SQUARE_BRACKET: "[">
}

TOKEN:
{
    <CLOSE_SQUARE_BRACKET: "]">
}


TOKEN:
{
    <NODE_ID_START: "_:">
}

TOKEN:
{
    <TRUE: "true">
}

TOKEN:
{
    <FALSE: "false">
}

TOKEN:
{
    <SELECT: "SELECT">
}

TOKEN:
{
    <WHERE: "WHERE">
}

TOKEN:
{
    <FILTER: "FILTER">
}

TOKEN:
{
    <LETTER: ["a"-"z"] | ["A"-"Z"]>
}

TOKEN:
{
    <URITOKEN: "<" (~[">"])* ">">
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// URIs

TOKEN:
{
    <QURI: "<"(<NCCHAR1> | "#" | "_")(~[">", " "])*">">
}

//TOKEN:
//{
//    <QNAME_NS: (<NCNAME1>)? ":">
//}

TOKEN:
{
    <QNAME: (<NCNAME1>)? ":" (<NCNAME1> | <NCNAME2>)?>
}

TOKEN:
{
    <BLANK_NODE: "_:" (<NCNAME1> | <NCNAME2>)?>
}

TOKEN:
{
    <NCNAME1: <NCCHAR1> (<NCCHAR_FULL>)*>
}

TOKEN:
{
    <NCNAME2: "_" (<NCCHAR_FULL>)*>
}

TOKEN:
{
    <NCCHAR_FULL: <NCCHAR1> | "_" | "-" | ["0"-"9"] | "\u00B7">
}

TOKEN:
{
    <VAR: "?"(<NCNAME1> | <NCNAME2>)>
}

TOKEN:
{
    <NCCHAR1: ["A"-"Z"]
        | ["a"-"z"]
        | ["\u00C0" - "\u00D6"]
        | ["\u00D8"-"\u00F6"]
        | ["\u00F8"-"\u02FF"]
        | ["\u0370"-"\u037D"]
        | ["\u037F"-"\u1FFF"]
        | ["\u200C"-"\u200D"]
        | ["\u2070"-"\u218F"]
        | ["\u2C00"-"\u2FEF"]
        | ["\u3001"-"\uD7FF"]
        | ["\uF900"-"\uFFFF"]>
}

TOKEN:
{
    <ERROR: ~[]>
}

/////////////////////////////////////////////////////////////////////////////////////////////

//TOKEN:
//{
//    <LONG_STRING: (<QUOTE><QUOTE><QUOTE>~["\""]<QUOTE><QUOTE><QUOTE>)>
//}



void parseDocument() :
{
}
{
    
    (parseDirective() | parseStatement())+<EOF> {handler.handleEnd();}
}

void parseDirective() :
{
}
{
    parsePrefixDirective() | parseBaseDirective()
}

void parsePrefixDirective() :
{
    Token t;
    String prefix = "";
    URI ns;
}
{
    <PREFIX> t=<QNAME>{prefix=t.image.substring(0, t.image.indexOf(':'));} ns=parseURIRef() <DOT> {
        prefix2NamespaceMap.put(prefix, ns.toString());
        handler.handlePrefixDirective(prefix, ns.toString());
    }
}

void parseBaseDirective() :
{
    URI baseURI;
    Token t;
}
{
    <BASE> t=<URITOKEN> {base = t.image.substring(1, t.image.length() - 1);} <DOT> {
        handler.handleBaseDirective(base);
    }
}

void parseStatement() :
{
}
{
    parseTriples()
}

void parseTriples() :
{
    URI subject;
}
{
    subject = parseSubject() (parsePredicateObjectList(subject))? (<DOT>)
}

URI parseSubject() :
{
    URI uri;
}
{
    (uri=parseResource() | uri=parseBlankNode()) {
        return uri;
    }
}

URI parseQName() :
{
    URI uri;
    Token t;
}
{
    t=<QNAME> {
        return getURIFromQName(t.image);
    }
}

URI parseURIRef() :
{
    Token t;
    URI uri;
}
{
    t=<URITOKEN> {return getURI(t.image);}
}

URI parseBlankNode() :
{
    URI uri;
}
{
    (uri=parseNodeID()
    |
    <EMPTY_BLANK_NODE>{uri = getNextBlankNode();}
    |
    <OPEN_SQUARE_BRACKET> {uri = getNextBlankNode();} parsePredicateObjectList(uri) (<DOT>)? <CLOSE_SQUARE_BRACKET>
    |
    uri = parseCollection()) {
        return uri;
    }
}

URI parseNodeID() :
{
    Token t;
}
{
    t=<BLANK_NODE> {
        return getURIFromQName(t.image);
    }
}

void parsePredicateObjectList(URI subject) :
{
    URI predicate;
}
{
    predicate=parseVerb() parseObjectList(subject, predicate) (<SEMICOLON> predicate=parseVerb() parseObjectList(subject, predicate) )*
}

URI parseVerb() :
{
    URI uri;
}
{
    (<A>{uri = OWLRDFVocabulary.RDF_TYPE.getURI();} | uri=parsePredicate()) {
        return uri;
    }
}

URI parsePredicate() :
{
    URI uri;
}
{
    uri=parseResource() {
        return uri;
    }
}

URI parseResource() :
{
    URI uri;
}
{
    (uri=parseURIRef() | uri=parseQName() | uri=parseVar()) {
        return uri;
    }
}

URI parseVar() :
{
    Token t;
}
{
    t=<VAR> {
        return getURI(t.image.substring(0, t.image.length()));
    }
}

void parseObjectList(URI subject, URI predicate) :
{
    
}
{
    parseObject(subject, predicate) ( <COMMA> parseObject(subject, predicate) )*
}

void parseObject(URI subject, URI predicate) :
{
    URI resObject;
}
{
    (parseLiteral(subject, predicate) 
    |
    ((resObject=parseResource()
    |
    resObject=parseBlankNode())) {
        handler.handleTriple(subject, predicate, resObject);
    })
}

URI parseCollection() :
{
    URI uri;
}
{
    <OPENPAR> uri=parseItemList() <CLOSEPAR> {
        return uri;
    }
}

URI parseItemList() :
{
    //  _x  rdf:type rdf:List
    //  _x  rdf:first
    //  _x  rdf:next
    URI firstSubject = null;
    URI subject = null;
    URI type = OWLRDFVocabulary.RDF_TYPE.getURI();
    URI first = OWLRDFVocabulary.RDF_FIRST.getURI();
    URI rest = OWLRDFVocabulary.RDF_REST.getURI();
    URI list = OWLRDFVocabulary.RDF_LIST.getURI();
    URI nil = OWLRDFVocabulary.RDF_NIL.getURI();
}
{
    (
    {
        URI prevSubject = subject;
        subject=getNextBlankNode();
        if(prevSubject != null) {
            handler.handleTriple(prevSubject, rest, subject);
        }
        else {
            firstSubject = subject;
        }
        handler.handleTriple(subject, type, list);
    }
        parseObject(subject, first))* {
        // Terminate list
        handler.handleTriple(subject, rest, nil);
        return firstSubject;
    }
}

String parseName() :
{
    Token t;
}
{
    t=<QNAME>{
        return t.image;
    }
}


void parseLiteral(URI subject, URI predicate) :
{
    String literal;
    String lang = null;
    URI datatype = null;
    Token t;
}
{
    (literal=parseQuotedString() ((<DOUBLE_CARET> datatype=parseResource()) | (("@" (t=<NCNAME1>)+){lang=t.image;}))?
        {
            if(datatype != null) {
                handler.handleTriple(subject, predicate, literal, datatype);
            }
            else if(lang != null) {
                handler.handleTriple(subject, predicate, literal, lang);
            }
            else {
                handler.handleTriple(subject, predicate, literal);
            }

        }
    )
    |
    (literal=parseInteger(){handler.handleTriple(subject, predicate, literal, XSDVocabulary.INTEGER.getURI());})
    |
    (literal=parseDouble(){handler.handleTriple(subject, predicate, literal, XSDVocabulary.DOUBLE.getURI());})
    |
    (literal=parseDecimal(){handler.handleTriple(subject, predicate, literal, XSDVocabulary.DECIMAL.getURI());})
    |
    (literal=parseBoolean(){handler.handleTriple(subject, predicate, literal, XSDVocabulary.BOOLEAN.getURI());})
}


String parseInteger() :
{
    Token t;
}
{
    t=<INTEGER> {
        return t.image;
    }
    |
    t=<DIGIT> {
        return t.image;
    }
}

String parseDouble() :
{
    Token t;
}
{
    t=<DOUBLE> {
        return t.image;
    }
}

String parseDecimal() :
{
    Token t;
}
{
    t=<DECIMAL> {
        return t.image;
    }
}

String parseBoolean() :
{
    Token t;
}
{
    (t=<TRUE> | t=<FALSE>) {
        return t.image;
    }
}

String parseQuotedString() :
{
    String s;
}
{
    s=parseString() {
        return s;
    }
}


String parseString() :
{
    Token t;
    String rawString = "";
}
{
    (t=<STRING> {
        rawString = t.image.substring(1, t.image.length() - 1);
    }
    | t=<LONG_STRING> {
        rawString = t.image.substring(3, t.image.length() - 3);
     }) {
        return EscapeUtils.unescapeString(rawString);
     }
}
